{"componentChunkName":"component---src-templates-docs-js","path":"/references/aggregations-api","result":{"data":{"site":{"siteMetadata":{"title":"Hypi Documentation","docsLocation":"https://github.com/hypi-universe/docs/tree/master/content"}},"mdx":{"fields":{"id":"da824609-5df8-5b34-aea0-74507afd4a3d","title":"Aggregations API","slug":"/references/05-aggregations-api"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Aggregations API\",\n  \"metaTitle\": \"Hypi Platform Aggregations Documentation\",\n  \"metaDescription\": \"Hypi platform documentation for the aggregations API\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Overview\"), mdx(\"p\", null, \"It's common to want to measure various things. By measuring we can gain insights into how things are performing and more.\\nIn Hypi, you can use the aggregations API to start to get insights about the data in your apps.\"), mdx(\"p\", null, \"Aggregations, like many other APIs are automatically generated.\\nAny scalar field can be aggregated in at least one way.\"), mdx(\"p\", null, \"String fields can only be counted or grouped whilst numeric fields have a range of mathematical operations which can be used to perform aggregations on them.\\nFor both Int and Float fields, the following operations are possible:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"avg\"), \" - calculates the average of a field\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"count\"), \" - count the number of entries with the given field\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sum\"), \" - sums the field\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"max\"), \" - finds the max value of a field\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"min\"), \" - finds the min value of a field\")), mdx(\"h2\", null, \"Generated types\"), mdx(\"p\", null, \"On this page we'll use the following schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Message {\\n    content: String!\\n    from: Account\\n    to: Account\\n}\\n\\nenum RatingType { POSITIVE, NEGATIVE}\\n\\ntype Rating {\\n  value: Float!\\n  type: RatingType!\\n}\\n\")), mdx(\"p\", null, \"Each app has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HypiAggregationType\"), \" which is a type dynamically generated based on your app's schema.\\nIn this case there will be something similar to\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type HypiAggregationType {\\n  message(where: String): MessageAggs\\n  messageWith(where: String, groupBy: [MessageGroupByOptions!]!,having: String, first: Int, after: String, last: Int, before: String, includeTrashed: Boolean): [MessageAggs]\\n  rating(where: String): RatingAggs\\n  ratingWith(where: String, groupBy: [RatingGroupByOptions!]!,having: String, first: Int, after: String, last: Int, before: String, includeTrashed: Boolean): [RatingAggs]\\n  ...\\n}\\n\")), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Parameter\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"where\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Filters rows before they are summarised into groups by the GROUP BY clause\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"groupBy\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Combines rows into groups based on matching values in specified columns. One row is returned for each group.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"having\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Filters rows after the results are grouped\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"first\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Limit the number of results returned when used with the \", mdx(\"strong\", {\n    parentName: \"td\"\n  }, \"after\"), \" parameter\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"after\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Return data after this token. This is the ID of an object returned previously that you'd like to get results following it\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"last\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Limit the number of results returned when used with the \", mdx(\"strong\", {\n    parentName: \"td\"\n  }, \"before\"), \" parameter\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"before\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Return data before this token. This is the ID of an object returned previously that you'd like to get results before it\")))), mdx(\"p\", null, \"The are two fields per type. The main difference as you can see is the parameters.\\nThe simpler method, does not have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"groupBy\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"having\"), \" parameters.\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"groupBy\"), \" type changes depending on the type.\\nHere we have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MessageGroupByOptions\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RatingGroupByOptions\"), \". This type changes because it uses the fields from the respective type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"input MessageGroupByOptions {\\n  field: MessageScalarFields!\\n  order: AggOrder\\n  dateGranularity: TimeUnit\\n}\\n\\ninput RatingGroupByOptions {\\n  field: RatingScalarFields!\\n  order: AggOrder\\n  dateGranularity: TimeUnit\\n}\\n\\nenum RatingScalarFields {\\n  value\\n  type\\n}\\n\\nenum MessageScalarFields {\\n  content\\n}\\n\")), mdx(\"p\", null, \"The key difference is between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RatingScalarFields\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MessageScalarFields\"), \" where each contains the name of the fields from their associated type.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"For the examples below we will need some data. Use add these entries to be able to get the results shown in the example.\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\nmutation Upsert($values: HypiUpsertInputUnion!) {\\n  upsert(values: $values) {\\n    id\\n  }\\n}\\n#Data\\n{\\n  \\\"values\\\": {\\n    \\\"Rating\\\": [\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating1\\\"},\\n        \\\"value\\\": 4,\\n        \\\"type\\\": \\\"POSITIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating2\\\"},\\n        \\\"value\\\": 4,\\n        \\\"type\\\": \\\"POSITIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating3\\\"},\\n        \\\"value\\\": 2,\\n        \\\"type\\\": \\\"NEGATIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating4\\\"},\\n        \\\"value\\\": 3,\\n        \\\"type\\\": \\\"POSITIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating5\\\"},\\n        \\\"value\\\": 5,\\n        \\\"type\\\": \\\"POSITIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating6\\\"},\\n        \\\"value\\\": 1,\\n        \\\"type\\\": \\\"NEGATIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating7\\\"},\\n        \\\"value\\\": 5,\\n        \\\"type\\\": \\\"POSITIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating8\\\"},\\n        \\\"value\\\": 1,\\n        \\\"type\\\": \\\"NEGATIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating9\\\"},\\n        \\\"value\\\": 2,\\n        \\\"type\\\": \\\"NEGATIVE\\\"\\n      },\\n      {\\n        \\\"hypi\\\": {\\\"id\\\": \\\"rating10\\\"},\\n        \\\"value\\\": 2,\\n        \\\"type\\\": \\\"NEGATIVE\\\"\\n      }\\n    ]\\n  }\\n}\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"upsert\\\": [\\n      {\\n        \\\"id\\\": \\\"rating1\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating2\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating3\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating4\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating5\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating6\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating7\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating8\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating9\\\"\\n      },\\n      {\\n        \\\"id\\\": \\\"rating10\\\"\\n      }\\n    ]\\n  }\\n}\\n\")))), mdx(\"h3\", null, \"Example 1 - no filters\"), mdx(\"p\", null, \"In this example we want to aggregate all the ratings.\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  aggregate{\\n    rating{\\n      value{\\n        avg\\n        count\\n        max\\n        min\\n        sum\\n      }\\n    }\\n  }\\n}\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"aggregate\\\": {\\n      \\\"rating\\\": {\\n        \\\"value\\\": {\\n          \\\"avg\\\": 2.9,\\n          \\\"count\\\": 10,\\n          \\\"max\\\": 5,\\n          \\\"min\\\": 1,\\n          \\\"sum\\\": 29\\n        }\\n      }\\n    }\\n  }\\n}\\n\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Select only what you need\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"By selecting the aggregation field, it will be calculated and returned.\\nDo not select a field if it's not needed, Hypi will only do the work to perform these calculations if you select the field.\\nThis means you can get faster queries by selecting less when the others are not needed.\")), mdx(\"h3\", null, \"Example 2 - aggregate distinct rows\"), mdx(\"p\", null, \"In this example we want to aggregate only unique ratings.\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  aggregate{\\n    rating{\\n      value{\\n        avg(distinct: true)\\n        count(distinct: true)\\n        sum(distinct: true)\\n      }\\n    }\\n  }\\n}\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"aggregate\\\": {\\n      \\\"rating\\\": {\\n        \\\"value\\\": {\\n          \\\"avg\\\": 3,\\n          \\\"count\\\": 5,\\n          \\\"sum\\\": 15\\n        }\\n      }\\n    }\\n  }\\n}\\n\")))), mdx(\"h3\", null, \"Example 2 - aggregate matching rows\"), mdx(\"p\", null, \"In this example we want to aggregate only positive ratings.\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  aggregate{\\n    rating(where: \\\"type = 'POSITIVE'\\\"){\\n      value{\\n        avg\\n        count\\n        sum\\n      }\\n    }\\n  }\\n}\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"aggregate\\\": {\\n      \\\"rating\\\": {\\n        \\\"value\\\": {\\n          \\\"avg\\\": 4.2,\\n          \\\"count\\\": 5,\\n          \\\"sum\\\": 21\\n        }\\n      }\\n    }\\n  }\\n}\\n\")))), mdx(\"h3\", null, \"Example 3 - group by\"), mdx(\"p\", null, \"In this example we want to aggregate and group by type.\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  aggregate {\\n    ratingWith(groupBy: [{ field: type, order: ASC }]) {\\n      value {\\n        avg\\n        count\\n        sum\\n        groupValues {\\n                    key\\n                    value\\n                }\\n      }\\n    }\\n  }\\n}\\n\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"aggregate\\\": {\\n      \\\"ratingWith\\\": [\\n        {\\n          \\\"value\\\": {\\n            \\\"avg\\\": 1.6,\\n            \\\"count\\\": 5,\\n            \\\"sum\\\": 8,\\n            \\\"groupValues\\\": [\\n              {\\n                \\\"key\\\": \\\"type\\\",\\n                \\\"value\\\": \\\"NEGATIVE\\\"\\n              }\\n            ]\\n          }\\n        },\\n        {\\n          \\\"value\\\": {\\n            \\\"avg\\\": 4.2,\\n            \\\"count\\\": 5,\\n            \\\"sum\\\": 21,\\n            \\\"groupValues\\\": [\\n              {\\n                \\\"key\\\": \\\"type\\\",\\n                \\\"value\\\": \\\"POSITIVE\\\"\\n              }\\n            ]\\n          }\\n        }\\n      ]\\n    }\\n  }\\n}\\n\")))), mdx(\"p\", null, \"As you can see, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"groupBy\"), \" field, which accepts a list of fields and options about the field such as sort order.\\nIn this case there are two possible values for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \", so we have two groups in the results.\"), mdx(\"h3\", null, \"Example 4 - aggregate by date\"), mdx(\"p\", null, \"In this example we want to aggregate and group by a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime field\"), \".\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  aggregate {\\n    ratingWith(\\n      groupBy: [{ field: hypi_updated, dateGranularity: MINUTES }]\\n    ) {\\n      value {\\n        avg\\n        count\\n        sum\\n        groupValues {\\n          key\\n          value\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"aggregate\\\": {\\n      \\\"ratingWith\\\": [\\n        {\\n          \\\"value\\\": {\\n            \\\"avg\\\": 2.2,\\n            \\\"count\\\": 5,\\n            \\\"sum\\\": 11,\\n            \\\"groupValues\\\": [\\n              {\\n                \\\"key\\\": \\\"hypi_updated\\\",\\n                \\\"value\\\": \\\"2020-07-17 04:14\\\"\\n              }\\n            ]\\n          }\\n        },\\n        {\\n          \\\"value\\\": {\\n            \\\"avg\\\": 4,\\n            \\\"count\\\": 2,\\n            \\\"sum\\\": 8,\\n            \\\"groupValues\\\": [\\n              {\\n                \\\"key\\\": \\\"hypi_updated\\\",\\n                \\\"value\\\": \\\"2020-07-17 04:42\\\"\\n              }\\n            ]\\n          }\\n        },\\n        {\\n          \\\"value\\\": {\\n            \\\"avg\\\": 3.3333333333333335,\\n            \\\"count\\\": 3,\\n            \\\"sum\\\": 10,\\n            \\\"groupValues\\\": [\\n              {\\n                \\\"key\\\": \\\"hypi_updated\\\",\\n                \\\"value\\\": \\\"2020-07-17 04:43\\\"\\n              }\\n            ]\\n          }\\n        }\\n      ]\\n    }\\n  }\\n}\\n\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" fields\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Only date time fields can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dateGranularity\"), \" parameter\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#overview","title":"Overview"},{"url":"#generated-types","title":"Generated types"},{"url":"#examples","title":"Examples","items":[{"url":"#example-1---no-filters","title":"Example 1 - no filters"},{"url":"#example-2---aggregate-distinct-rows","title":"Example 2 - aggregate distinct rows"},{"url":"#example-2---aggregate-matching-rows","title":"Example 2 - aggregate matching rows"},{"url":"#example-3---group-by","title":"Example 3 - group by"},{"url":"#example-4---aggregate-by-date","title":"Example 4 - aggregate by date"}]}]},"parent":{"__typename":"File","relativePath":"references/05-aggregations-api.md"},"frontmatter":{"metaTitle":"Hypi Platform Aggregations Documentation","metaDescription":"Hypi platform documentation for the aggregations API"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/404","title":"Page Not Found"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/","title":"Platform Documentation"}}},{"node":{"fields":{"slug":"/references","title":"API & References"}}},{"node":{"fields":{"slug":"/products","title":"Products"}}},{"node":{"fields":{"slug":"/recipes","title":"Recipes"}}},{"node":{"fields":{"slug":"/tutorials","title":"Tutorials"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql","title":"GraphQL"}}},{"node":{"fields":{"slug":"/tutorials/01-instance","title":"Instances"}}},{"node":{"fields":{"slug":"/references/00-app","title":"Apps"}}},{"node":{"fields":{"slug":"/tutorials/04-graph","title":"Graph Queries"}}},{"node":{"fields":{"slug":"/references/01-api","title":"API Setup"}}},{"node":{"fields":{"slug":"/tutorials/04-dateGranularity","title":"Timeseries Aggregations with Date Granularity"}}},{"node":{"fields":{"slug":"/references/03-authorisation","title":"Authorisation"}}},{"node":{"fields":{"slug":"/reference","title":"Reference"}}},{"node":{"fields":{"slug":"/references/04-api-gateway","title":"API Gateway"}}},{"node":{"fields":{"slug":"/references/07-workflow","title":"Workflows"}}},{"node":{"fields":{"slug":"/references/11-serverless-functions","title":"Serverless functions"}}},{"node":{"fields":{"slug":"/references/08-webhooks","title":"Webhooks"}}},{"node":{"fields":{"slug":"/references/10-triggers","title":"Triggers"}}},{"node":{"fields":{"slug":"/references/09-math-api","title":"Math API"}}},{"node":{"fields":{"slug":"/references/15-oauth2-login","title":"OAuth2 Login"}}},{"node":{"fields":{"slug":"/references/13-analytics","title":"Analytics"}}},{"node":{"fields":{"slug":"/references/16-iot","title":"IoT"}}},{"node":{"fields":{"slug":"/references/12-user-defined-functions","title":"User Defined Functions"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/01-intro","title":"Introduction"}}},{"node":{"fields":{"slug":"/getting-started/01-scratch","title":"Starting from scratch"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/03-query","title":"Queries"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/04-mutation","title":"Mutations"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/05-subscription","title":"Subscriptions"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/06-hypi-object","title":"Magic Hypi Object"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/07-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/references/14-file-upload","title":"File upload API"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/08-interfaces","title":"Interfaces"}}},{"node":{"fields":{"slug":"/faq","title":"FAQs"}}},{"node":{"fields":{"slug":"/tutorials/03-crud","title":"Hypi GraphQL CRUD Tutorial"}}},{"node":{"fields":{"slug":"/references/02-crud","title":"CRUD"}}},{"node":{"fields":{"slug":"/references/05-aggregations-api","title":"Aggregations API"}}},{"node":{"fields":{"slug":"/references/06-rest-api","title":"RESTful APIs"}}},{"node":{"fields":{"slug":"/getting-started/02-angular","title":"Hypi + Angular"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/02-schema-and-types","title":"Schema & Types"}}},{"node":{"fields":{"slug":"/references/02-arcql","title":"ArcQL Filtering"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"da824609-5df8-5b34-aea0-74507afd4a3d"}}}