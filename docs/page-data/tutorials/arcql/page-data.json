{"componentChunkName":"component---src-templates-docs-js","path":"/tutorials/arcql","result":{"data":{"site":{"siteMetadata":{"title":"Hypi Documentation","docsLocation":"https://github.com/hypi-universe/docs/tree/master/content"}},"mdx":{"fields":{"id":"84189d20-fbee-5aba-9067-e3e56a8bea31","title":"ArcQL Filtering","slug":"/tutorials/02-arcql"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"ArcQL Filtering\",\n  \"metaTitle\": \"Hypi tutorial for ArcQL\",\n  \"metaDescription\": \"How to find data in the Hypi platform using ArcQL\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"A SQL-like query language used to filter, sort and paginate data in the platform.\\nHypi offers a powerful query language as part of its platform.\"), mdx(\"p\", null, \"ArcQL is modelled off of the Apache Lucene query language. We went further and included some SQL like features e.g. SORT, FROM, LIMIT.\"), mdx(\"h2\", null, \"Query Structure\"), mdx(\"p\", null, \"\\u200CArcQL is made up of four major components.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<query> <sort> <from> <limit>\"), \"  i.e. it is very SQL like. Designed intentionally so to help make the learning curve as small as possible for our developers.\\nIf you\\u2019re familiar with SQL or the Lucene query language you\\u2019ll probably be able to write ArcQL queries by just guessing at it.\\n\\u200CLet\\u2019s break the four components down but leave query for last since it is the most complex.\"), mdx(\"h3\", null, \"ArcQL Pagination\"), mdx(\"p\", null, \"For specifying a paging token\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FROM 'some token'\"), \"  this is all there is to it. When you search, every object returned by the API includes their paging token in the special hypi field.\\nTake the token from the last object we returned to you and pass it back. We will then send back results after this object.\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${_arcql} LIMIT ${limit} FROM ${fromToken}\")), mdx(\"h3\", null, \"ArcQL: Sorting\"), mdx(\"p\", null, \"For specifying how to sort matching results\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{arcql: fieldName SORT hypi.created ASC|DES}\\u200C\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a ASC\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a DESC\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a, b.c DESC, c\"))), mdx(\"h3\", null, \"ArcQL Limiting\"), mdx(\"p\", null, \"For limiting the number of results returned, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT 50\"), \"  this is all there is to it, when you search we will impose a max limit the query, currently \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${_arcql} LIMIT ${limit}\")), mdx(\"h3\", null, \"ArcQL Term Query\"), mdx(\"p\", null, \"A term query is a simple filter asking to return results that match the value provided exactly. Examples:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a = 'some string'\\na = 123\\na = 'some string' OR 123 AND 'abc'\\n\")), mdx(\"p\", null, \"\\u200CBoolean Logic is possible on all query types. The general form is as demonstrated on line 3 (the last example). The last example says \\u201Creturn objects where field a is\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"some string\"), \" or where a is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"123\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" a is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abc\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This query is non-sensical because and will only return objects that have a set to  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abc\"), \".  \\u200CThe reason for this is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" is treated as an absolute assertion requiring that the given field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MUST\"), \"  have the requested value in order for it to match.\")), mdx(\"h3\", null, \"ArcQL Phrase Query\"), mdx(\"p\", null, \"A phrase query is similar to what an end user might expect a search engine to do. You search for  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"New York\"), \" it will return objects containing this exact phrase or the individual words.\"), mdx(\"p\", null, \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldName ~ '${query}' OR fieldName ~ '${query}' OR fieldName ~ '${query}' fieldName ~  '${query}'\"), \";\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a ~ 'some string'\\n\\na ~ 123\\n\\na ~ 'some string' OR 123\\n\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", null, \"ArcQL EXIST\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EXIST a\"), \"\\nThis asserts that the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" exists i.e. only data where the field exists will match\"), mdx(\"h3\", null, \"ArcQL NOT EXIST\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NOT EXIST b\"), \"\\nThis asserts that the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" does \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" exist i.e. only data where the field does NOT exist will match\"), mdx(\"h3\", null, \"ArcQL Prefix Query\"), mdx(\"p\", null, \"A prefix query will take the terms you\\u2019ve searched for and match any object where the contents of the field starts with those terms\\na ^ 'some string'\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a ^ 123\\n\\na ^ 'some string' OR 123\\n\")), mdx(\"h3\", null, \"ArcQL Wildcard Query\"), mdx(\"p\", null, \"A wildcard query takes the terms searched for and treats  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" as special characters.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" Means match anything from this point onwards\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" Means match any single character at this position\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a * 'some'\\n\\na * 123\\n\\na * 'some?str*' OR 123\\n\")), mdx(\"div\", null), mdx(\"br\", null), mdx(\"h3\", null, \"ArcQL Fuzzy Query\"), mdx(\"p\", null, \"A fuzzy query takes the terms searched for and tries to match words that are similar even if spelt slightly differently e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tame\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"game\"), \"  would match if you searched for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tame\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"~ a ~ 'some string'\\n\\n~ a ~[1] 'some string' OR 'other string'\\n\\n~ a ~[1,5] 'some string' OR 'other string'\\n\\n~ a ~[1,5,10] 'some string' OR 'other string'\\n\\n~ a ~[1,5,10,true] 'some string' OR 'other string'\\n\")), mdx(\"p\", null, \"The numbers and the boolean all you to tweak how the fuzzy algorithm runs. The parameters are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1. max edits\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2. prefix length\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" 3. max expansion\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4. allow transpositions\"), \"  In that order.\"), mdx(\"h3\", null, \"ArcQL Range Query\"), mdx(\"p\", null, \"\\u200CRange queries are a means for you to search for content that falls within the given range.\\na IN [0, 1)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a IN (0, 1]\\n\\na IN (0, 1)\\n\\na IN [0, 1]\\n\\n//any of the above can also use boolean logic e.g.\\n\\na IN [0, 1 OR 5,10 AND 10, 11)\\n\\n\\n\\n//all of the above also works for strings\\n\\na IN ['America', 'Jamaica')\\n\")), mdx(\"p\", null, \"These are the standard mathematical representations of ranges and work exactly as you\\u2019d expect i.e.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[0,1)\"), \" left inclusive, i.e. including 0, excluding 1\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(0,1]\"), \" right inclusive, i.e. excluding 0, including 1\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(0,1)\"), \" exclusive, i.e. not including 0 or 1, only those between\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[0,1]\"), \" inclusive, i.e. including both 0, 1 and everything in between\")), mdx(\"h3\", null, \"ArcQL Match All Query\"), mdx(\"p\", null, \"A match all query is simple a query with the value *, it will return all documents unless other filters restrict it.\\n\\u200C\\u200CCombining the various queries work as expected\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(a = 'something' OR b ~ 'New York') AND (c ^ 'alpha' OR ~d~ \\\"something\\\" OR a IN [0,10))\")), mdx(\"h3\", null, \"ArcQL REF FROM\"), mdx(\"p\", null, \"\\u200CHypi is a polyglot storage service, one of the supported storage paradigms is for graph data, see the API Guide for more information. ArcQL has support for querying graph data.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REF FROM '<Origin Type>' ON '<Origin Field>' FOR '<Origin ID>' WHERE <ArcQL filter>\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u200COrigin Type\"), \" is the name of the GraphQL type from which you would like to find edges\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Origin Field\"), \" is the name of the field on the Origin Type for which the edge exists\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Origin ID\"), \" is the ID of the object/vertex to find references from\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ArcQL filter\"), \" is any valid ArcQL query, this is optional and if present will only return edges that match\")), mdx(\"h3\", null, \"ArcQL Geo Location\"), mdx(\"p\", null, \"Hypi allows developers to run search within a radius of a point defined by longitude and latitude.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"geo(latitude, longitude, radius, latitudeFieldName, longitudeFieldName)\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"latitude\"), \": defined in radians by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"latitude * Pi / 180\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"longitude\"), \": defined in radians by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"longitude * Pi / 180\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"radius\"), \": defined in kilometers, for example, 0.5 stands for 500 meters\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"latitudeFieldName\"), \": The name of the latitude field as defined on the GraphQL type\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"longitudeFieldName\"), \": The name of the longitude field as defined on the GraphQL type\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"latitudeFieldName\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"longitudeFieldName\"), \" give the developers the flexibility to use any float/double decimal point numbers as the source of latitude and longitude. For example, assume that a type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GPS\"), \" is defined in your App schema as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type GPS {\\n    x: Float\\n    y: Float\\n}\\n\")), mdx(\"p\", null, \"Then, in this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"latitudeFieldName\"), \" should be set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"longitudeFieldName\"), \" should be set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \".\"), mdx(\"p\", null, \"In order to query the locations within a radius of 500 meters of a point degrees(31.9913129, 34.8661077) which is equal to radians(0.55835, 0.60852). Then, the query should look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n    find(\\n        type:GPS,\\n        arcql:\\\"geo(0.55835,0.60852,0.5,'x','y')\\\"\\n    ) {\\n        edges{\\n            node{\\n                ... on GPS {\\n                    hypi {\\n                        id\\n                    }\\n                    x\\n                    y\\n                }\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"In summary, the Geo Location features of ArcQL, can be described to satisfy the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any object with float fields can be used - not just GPS as shown in example\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The value of the fields MUST be radians NOT degrees\")), mdx(\"p\", null, \"Another example:\"), mdx(\"p\", null, \"Create some data - again, x and y values are in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"radians\"), \" not degrees.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"mutation {\\n  upsert(\\n    values: {\\n      GPS: [\\n        {x: 0.55835374214, y: 0.6084901767 }\\n        {x: 0.55835374214, y: 0.6084901767 }\\n        {x: -0.41167494186, y: -0.81812175344 }\\n        {x: -0.41786913283, y: -0.80969561972 }\\n        {x: -0.41776046165, y: -0.81033767224 }\\n        {x: 0.89901594913, y: -0.002154727644 }\\n        {x: 0.89938548071, y: -0.0022373637481 }\\n        {x: 0.90000538675, y: -0.0027382086662 }\\n        {x: 0.55843351241, y: 0.60848146576 }\\n        {x: 0.55769501648, y: 0.60841038723 }\\n        { x: 0.55831914971, y: 0.60843128929 }\\n      ]\\n    }\\n  ) {\\n    id\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now we can find or objects within a given radius:\"), mdx(\"div\", {\n    className: \"code-container\"\n  }, mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"#GraphQL query\\n{\\n  find(type: GPS, arcql: \\\"geo(0.55835374214,0.60852837672,0.5,'x','y')\\\") {\\n    edges {\\n      node {\\n        ... on GPS {\\n          x\\n          y\\n        }\\n      }\\n    }\\n  }\\n}\\n\"))), mdx(\"div\", {\n    className: \"code-column\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"find\\\": {\\n      \\\"edges\\\": [\\n        {\\n          \\\"node\\\": {\\n            \\\"x\\\": 0.55835374214,\\n            \\\"y\\\": 0.6084901767\\n          }\\n        },\\n        {\\n          \\\"node\\\": {\\n            \\\"x\\\": 0.55835374214,\\n            \\\"y\\\": 0.6084901767\\n          }\\n        }\\n      ]\\n    }\\n  }\\n}\\n\")))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#query-structure","title":"Query Structure","items":[{"url":"#arcql-pagination","title":"ArcQL Pagination"},{"url":"#arcql-sorting","title":"ArcQL: Sorting"},{"url":"#arcql-limiting","title":"ArcQL Limiting"},{"url":"#arcql-term-query","title":"ArcQL Term Query"},{"url":"#arcql-phrase-query","title":"ArcQL Phrase Query"},{"url":"#arcql-exist","title":"ArcQL EXIST"},{"url":"#arcql-not-exist","title":"ArcQL NOT EXIST"},{"url":"#arcql-prefix-query","title":"ArcQL Prefix Query"},{"url":"#arcql-wildcard-query","title":"ArcQL Wildcard Query"},{"url":"#arcql-fuzzy-query","title":"ArcQL Fuzzy Query"},{"url":"#arcql-range-query","title":"ArcQL Range Query"},{"url":"#arcql-match-all-query","title":"ArcQL Match All Query"},{"url":"#arcql-ref-from","title":"ArcQL REF FROM"},{"url":"#arcql-geo-location","title":"ArcQL Geo Location"}]}]},"parent":{"__typename":"File","relativePath":"tutorials/02-arcql.md"},"frontmatter":{"metaTitle":"Hypi tutorial for ArcQL","metaDescription":"How to find data in the Hypi platform using ArcQL"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/404","title":"Page Not Found"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/","title":"Platform Documentation"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/products","title":"Products"}}},{"node":{"fields":{"slug":"/references","title":"API & References"}}},{"node":{"fields":{"slug":"/recipes","title":"Recipes"}}},{"node":{"fields":{"slug":"/tutorials","title":"Tutorials"}}},{"node":{"fields":{"slug":"/tutorials/01-instance","title":"Instances"}}},{"node":{"fields":{"slug":"/reference","title":"Reference"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql","title":"GraphQL"}}},{"node":{"fields":{"slug":"/tutorials/04-dateGranularity","title":"Timeseries Aggregations with Date Granularity"}}},{"node":{"fields":{"slug":"/tutorials/04-graph","title":"Graph Queries"}}},{"node":{"fields":{"slug":"/references/00-app","title":"Apps"}}},{"node":{"fields":{"slug":"/references/01-api","title":"API Setup"}}},{"node":{"fields":{"slug":"/references/04-api-gateway","title":"API Gateway"}}},{"node":{"fields":{"slug":"/references/07-workflow","title":"Workflows"}}},{"node":{"fields":{"slug":"/references/09-math-api","title":"Math API"}}},{"node":{"fields":{"slug":"/references/08-webhooks","title":"Webhooks"}}},{"node":{"fields":{"slug":"/references/10-triggers","title":"Triggers"}}},{"node":{"fields":{"slug":"/references/11-serverless-functions","title":"Serverless functions"}}},{"node":{"fields":{"slug":"/references/14-iot","title":"IoT"}}},{"node":{"fields":{"slug":"/references/12-user-defined-functions","title":"User Defined Functions"}}},{"node":{"fields":{"slug":"/references/13-analytics","title":"Analytics"}}},{"node":{"fields":{"slug":"/getting-started/01-scratch","title":"Starting from scratch"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/01-intro","title":"Introduction"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/03-query","title":"Queries"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/05-subscription","title":"Subscriptions"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/04-mutation","title":"Mutations"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/06-hypi-object","title":"Magic Hypi Object"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/08-interfaces","title":"Interfaces"}}},{"node":{"fields":{"slug":"/references/03-authorisation/00-permissions","title":"Permissions"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/07-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/references/03-authorisation/01-policies","title":"Policies"}}},{"node":{"fields":{"slug":"/faq","title":"FAQs"}}},{"node":{"fields":{"slug":"/tutorials/02-arcql","title":"ArcQL Filtering"}}},{"node":{"fields":{"slug":"/tutorials/03-crud","title":"Hypi GraphQL CRUD Tutorial"}}},{"node":{"fields":{"slug":"/references/05-aggregations-api","title":"Aggregations API"}}},{"node":{"fields":{"slug":"/references/02-crud","title":"CRUD"}}},{"node":{"fields":{"slug":"/references/03-authorisation","title":"Authorisation"}}},{"node":{"fields":{"slug":"/references/06-rest-api","title":"RESTful APIs"}}},{"node":{"fields":{"slug":"/getting-started/02-angular","title":"Hypi + Angular"}}},{"node":{"fields":{"slug":"/tutorials/00-graphql/02-schema-and-types","title":"Schema & Types"}}},{"node":{"fields":{"slug":"/references/03-authorisation/02-resource-based-permission","title":"Resource Permission"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"84189d20-fbee-5aba-9067-e3e56a8bea31"}}}